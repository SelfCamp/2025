board = new Board();
board.spawnTiles(2);

boardHistory = [board];
arrowPressHistory = [];

while isGameOngoing() {
  // Listen for arrow keys
}

handleEndOfGame();



const handleArrowPress = (event) => {

  let direction = // get from event
  arrowPressHistory.push(direction);

  let currentBoard = boardHistory[boardHistory.length-1];
  let nextBoard = createNextBoard(currentBoard, direction)
  boardHistory.push(nextBoard);

  updateMvAttributesInDOM(currentBoard, direction);
  setTimeout(() => squashBoardInDOM(nextBoard, direction), animationDuration);
}


createNextBoard(currentBoard, direction) {
  let nextBoard = squashBoard(currentBoard, direction);
  nextBoard.spawnTiles(1);
  return nextBoard;
}


const squashBoardInDOM(nextBoard, direction) {

}


const handleEndOfGame = () => {
  
}

const squashBoard = (currentBoard, direction) => {
  // make a copy
  // split into rows based on direction - keep references to tiles
  for (row of rows) {
    squashRow(row)  // mutates tiles in input
  }
}


const squashRow = (row) => {
  for (tile of row) {  // start from end
    // propagate to furthest empty slot
    // merge with next tile if (there is one && is of same value && hasn't been merged yet)
  }
}

const isGameOngoing = (board) => {
  return (maxTileValue < 2048 && !isBoardFull)
}
